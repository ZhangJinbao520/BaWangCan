# -*- coding: utf-8 -*-
# 
# 第八套中小学生广播体操，现在开始...
# 第一节，_φ(❐_❐✧ 人丑就要多读书
# ┏(＾0＾)┛  ┏(´0｀)┛  ┏(´0｀)┛  ┏(´0｀)┛
# ┗(＾0＾)┏  ┗(｀0´)┏  ┗(｀0´)┏  ┗(｀0´)┏
# ┏(´0｀)┏   ┏(´0｀)┏  ┗(｀0´)┛  ┗(｀0´)┛
# _(:ι」∠)_好饿，但是不想动
# 睡觉没前途(￣o￣) . z Z　
#
# Created by: PyQt5 UI code generator 5.15.2
# Created by: Python 3.8
#
# WARNING: Do not edit this file unless you know what you are doing.
# 
# See https://github.com/zhangjinbao3114/BaWangCan
# __author__ = "ZhangJinbao"
# Copyright(C) 2020 ZhangJinbao All rights reserved.

class linkStatusBackendThread(QtCore.QThread):
    '''
    QRCode的自定义信号线程
    作用：实时监测二维码登录状态
    '''
    linkStatus = QtCore.pyqtSignal(int)    # 自定义信号，queryQRCodeStatus的状态码
    def __init__(self, lgtoken):
        super().__init__()
        self.lgtoken = lgtoken
    
    def run(self):
        '''
        run()重写
        信号定义：
              -1  ：连接超时
               0  ：连接中...
               1  ：扫描成功
               2  ：确认登录
               3  ：取消登录
            Other ：连接异常
        '''
        url = 'https://account.dianping.com/account/ajax/queryqrcodestatus'    # queryQRCodeStatus的URL
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36'}
        data = {'lgtoken': self.lgtoken}
        while True:
            response = requests.post(url=url, headers=headers, data=data)
            if response.status_code == 200:
                status = response.json()['msg']['status']    # 返回状态码
                if status == 2:    # 提取cookie
                    self.saveConfig('config.ini', 'Cookie', 'Cookie', response.headers['set-Cookie'])
                self.linkStatus.emit(int(status))    # 发射信号
                time.sleep(0.5)    # 等待时间，防止线程一直占用CPU
            else:
                self.linkStatus.emit(int(response.status_code))

    @staticmethod
    def getConfig(file, section, option):
        '''
        读取config.ini配置文件
        文件格式：
            [Cookie]：Cookie = ...
            [Providence]：Providence = ...
            [City]：City = ...
        '''
        config = RawConfigParser()
        config.read(file, encoding='utf-8')    # 读取文件
        try:
            return config.get(section, option)
        except:
            return None

    @staticmethod
    def saveConfig(file, section, option, value=None):
        '''
        文件格式：
        保存config.ini配置文件
            [Cookie]：Cookie = ...
            [Providence]：Providence = ...
            [City]：City = ...
        '''
        config = RawConfigParser()
        config.read(file, encoding='utf-8')    # 读取文件
        try:
            config.add_section(section)    # 如果键值不存在，则创建键值
        except:
            pass
        config.set(section, option, value)
        config.write(open(file, "w+", encoding='utf-8'))    # 写入文件（读写模式）

class runStatusBackendThread(QtCore.QThread):
    '''
    [Run]按钮的自定义信号线程
    作用：[Run]按钮的文字切换
        '执行中.. '与'执行中...'切换
    '''
    runStatus = QtCore.pyqtSignal(str)    # 自定义信号
    def __init__(self, currentText):
        super().__init__()
        self.currentText = currentText

    def run(self):
        '''
        信号定义：
            开始执行
            执行中.. 
            执行中...
        '''
        while True:
            if self.currentText == "执行中.. ":
                self.runStatus.emit("执行中...")
            elif self.currentText == "执行中...":
                self.runStatus.emit("执行中.. ")
            else:
                time.sleep(1)
            time.sleep(0.25)

class runResultBackendThread(QtCore.QThread):
    '''
    免费试执行的自定义线程
    作用：自动报名免费试，生成表格、并微信推送报名结果
    '''
    runResult = QtCore.pyqtSignal()    # 自定义信号
    def __init__(self, cookie, city, userNickName):
        super().__init__()
        self.Cookie = cookie
        self.City = city
        self.userNickName = userNickName
        self.Rows = {
            '序号': 'No.',    # 自定义
            '活动名称': 'activityTitle',
            # '活动ID': 'offlineActivityId',
            '活动链接': 'detailUrl',
            '活动类型': 'mode',
            '活动名额': 'activityCount',    # 自定义
            '报名人数': 'applyCount',    # 自定义
            '关注人数': 'attentionCount',    # 自定义
            '中奖率（%）': 'winningRate',    # 活动名额/报名人数*100
            '活动商圈': 'regionName',
            '活动地址': 'activityAddress',    # 自定义
            '活动时间': 'activityTime',    # 自定义
            '报名时间': 'applyTime',    # 自定义
            '剩余PASS次数': 'passCount',    # 自定义
            '报名结果': 'applyResult',    # 自定义
        }
        self.Database = {}

    def run(self):
        '''
        run()重写
        信号定义：
            1、运行成功
            0、运行失败
        '''
        # mode = {
        #     1: '美食',
        #     2: '丽人',
        #     3: '婚假',
        #     4: '亲子',
        #     5: '家装',
        #     6: '玩乐',
        #     7: 'N/A',
        #     8: '培训',
        #     9: 'N/A',
        # }
        mode = {
            1: '聚会',
            2: 'V聚会',
            3: '电子券',
            4: '好礼到家',
            5: '天天抽奖',
        }
        self.PASS = 0
        self.SKIP = 0
        self.FAIL = 0
        count = 1
        activityTitles = self.getBaWangCan()    # 获取霸王餐列表
        for _activity in activityTitles:
            self.Database[count] = {}
            # 霸王餐
            for key in self.Rows.values():
                # 部分Rows字段为自定义字段
                try:
                    if key != 'mode':
                        self.Database[count][key] = _activity[key]
                    else:
                        self.Database[count][key] = mode[_activity[key]]
                except:
                    self.Database[count][key] = ''
            # 霸王餐详情
            details = self.getBaWangCanDetail(_activity['detailUrl'])
            for key in self.Rows.values():
                try:
                    self.Database[count][key] = details[key]
                except:
                    pass
            # 霸王餐报名
            offlineActivityId = _activity['detailUrl'].replace('http://s.dianping.com/event/', '')
            self.Database[count]['applyResult'] = self.runBaWangCan(offlineActivityId)
            self.Database[count]['No.'] = count
            count += 1
        # 写表格
        self.excelOperate(self.Database)    # 表格生成
        self.weixinTrap()    # 微信推送
        self.runResult.emit()

    # @staticmethod
    def getBaWangCan(self):
        '''
        获取霸王餐列表
        '''
        detail = []
        url = 'http://m.dianping.com/activity/static/pc/ajaxList'
        headers = {
            'Content-Type': 'application/json',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36'
        }
        data = {
            'cityId': self.City,
            'mode': "",
            'page': 1,
            'type': 0,    # type：霸王餐类型
        }
        while True:
            response = requests.post(url=url, headers=headers, data=json.dumps(data))
            if response.status_code == 200:
                hasNext = response.json()['data']['hasNext']
                detail += response.json()['data']['detail']
                if hasNext:
                    data['page'] += 1
                else:
                    break
            else:
                break
        return detail

    # @staticmethod
    def getBaWangCanDetail(self, url):
        '''
        获取霸王餐详情
        '''
        detail = {}
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36',
        }
        response = requests.get(url=url, headers=headers)
        if response.status_code == 200:
            detail['activityAddress'] = re.search(r'活动地址：</span>\s+(.*)\s', response.text)[1]
            detail['applyTime'] = re.search(r'报名时间：</span>(.*)', response.text)[1]
            detail['activityTime'] = re.search(r'活动时间：</span>(.*)</li>', response.text)[1]
            detail['activityCount'] = re.search(r'活动名额：</span>\s+<strong class="col-digit">(\d+)</strong> 个', response.text)[1]
            try:
                detail['passCount'] = re.search(r'支持pass卡（剩余(\d+)个）', response.text)[1]
            except:
                detail['passCount'] = '不支持'
            detail['applyCount'] = re.search(r'<strong>(\d+)</strong>人报名', response.text)[1]
            detail['attentionCount'] = re.search(r'<strong>(\d+)</strong>人关注', response.text)[1]
            detail['winningRate'] = "{0:.2f}".format(int(detail['activityCount'])/int(detail['applyCount']) * 100)
        return detail
    
    # @staticmethod
    def runBaWangCan(self, activatyID):
        '''
        报名霸王餐
        '''
        url = 'http://s.dianping.com/ajax/json/activity/offline/saveApplyInfo'
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8;',
            'Cookie': self.Cookie,
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36',
        }
        data = {
            'offlineActivityId': activatyID,
            'phoneNo': '',
            'shippingAddress': '',
            'extraCount': '',
            'birthdayStr': '',
            'email': '',
            'marryDayStr': time.strftime('%Y-%m-%d'),
            'babyBirths': time.strftime('%Y-%m-%d'),
            'pregnant': '',
            'marryStatus': '0',
            'comboId': '',
            'branchId': '',
            'usePassCard': '0',
            'passCardNo': '',
            'isShareSina': 'false',
            'isShareQQ': 'false',
        }
        response = requests.post(url=url, headers=headers, data=data)
        if response.status_code == 200:
            status = response.json()['code']
            if status == 200:
                msg = '报名成功'
                self.PASS += 1
            elif status == 500:
                msg = '重复报名'
                self.SKIP += 1
            else:
                msg = '报名异常'
                self.FAIL += 1
        else:
            msg = '报名异常'
            self.FAIL += 1
        return msg

    def weixinTrap(self):
        '''
        微信推送
        '''
        # 从http://sc.ftqq.com/?c=code获取微信推送的SCKEY，并绑定官微
        SCKEY = 'SCU155771T3549c0427011a83c02d53a4f054055166012211d21350'    # Server酱申请的SCKEY
        url = 'https://sc.ftqq.com/' + SCKEY + '.send'
        header = {
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36',
        }
        data = {
            'text': '大众点评免费试运行结果',
            'desp': '''
            {0} ， 用户名：***{1}***
            - 今日报名成功：**{2}**
            - 今日报名重复：**{3}**
            - 今日报名失败：**{4}**
            '''.format(time.strftime('%Y-%m-%d %H:%M:%S'), self.userNickName, self.PASS, self.SKIP, self.FAIL),
        }
        requests.post(url=url, headers=header, data=data)

    # @staticmethod
    def excelOperate(self, members):
        '''
        表格数据写入，并保存为.xlsx文件
        pararm :
            members : {k:{k:v},k:{k:v}...}
        return : Excel表格
        '''
        from openpyxl import Workbook
        excel = Workbook()
        sheet = excel.active    # 激活表格
        sheet.append(list(self.Rows.keys()))   # 写入首行数据
        for member in members.values():
            sheet.append(list(member.values()))
        excel.save("大众点评免费试报名结果" + time.strftime('%Y-%m-%d %H`%M`%S') + ".xlsx")